#include "llvm/CPT/CodePtrTagPass.h"
#include "llvm/CPT/CPT.h"

#define PARTS_USE_SHA3

extern "C" {
#include "../PARTS-sha3/include/sha3.h"
}

char CodePtrTagPass::ID = 0;
static RegisterPass<CodePtrTagPass> X("cpt-tag", "Code-pointer tagging pass");

Pass *llvm::CPT::createCodePtrTagPass() { return new CodePtrTagPass(); }

bool CodePtrTagPass::runOnModule(Module &M) {
	init(M);
  auto const cpiTy = llvm::CPT::getCptType();

  if (cpiTy == CptType::CptNone) {
		insertCptSet(M, 1);
	  return false;
	}

	errs() << "Start CPT pass!\n";

  CodePtrAliasPass &MT = getAnalysis<CodePtrAliasPass>();
  value_map = MT.getValueMap();

	CPT = (cpiTy == CptType::CPT);
	assert(CPT);
	QEMU = true;

	buildCFG(M);
	//handleFunctions(M);
	handleIndirectCalls(M);
  printFuncAddr(M);
	insertCptSet(M, 1);

	errs() << "statNumIndirectCall: " << statNumIndirectCall << "\n";
	errs() << "statNumESTR: " << statNumESTR << "\n";
	errs() << "statMaxNumCallee: " << statMaxNumCallee << "\n";
	errs() << "statMaxNumCalleePerCall: " << statMaxNumCalleePerCall << "\n";

	return true; // function_modified = true
}

void CodePtrTagPass::getAnalysisUsage(AnalysisUsage &AU) const {
	AU.setPreservesAll();
  AU.addRequired<CodePtrAliasPass>();
}

void CodePtrTagPass::buildCFG(Module &M) {
	map<Function *, set<Function *>*> edge_map;
	set<string> black_set({ 
		"llvm.va_start",
		"llvm.va_end",
		"llvm.lifetime.start.p0i8",
		"llvm.lifetime.end.p0i8",
		"llvm.dbg.declare",
		"llvm.dbg.label",
		"llvm.prefetch",
		"llvm.stacksave",
		"llvm.stackrestore",
		"llvm.floor.f64",
		"llvm.floor.f32",
		"llvm.ceil.f64",
		"llvm.ceil.f32",
		"llvm.fabs.f64",
		"llvm.fabs.f32",
		"llvm.va_copy",
		"llvm.round.f64",
		"llvm.trap"
	});

	for (auto &F: M) {
		//if (F.isDeclaration()) {
		//	errs() << "Intrinsic func: ";
		//	F.dump();
		//	errs() << "Type: "; F.getType()->dump();
		//}

		for (auto &BB : F) {
			for (auto &I : BB) {
				if (CallInst *pCI = dyn_cast<CallInst>(&I)) {
        	Function *pF = pCI->getCalledFunction();

					if (!pF) { // Indirect function call
						Function *caller = pCI->getFunction();
						auto op = pCI->op_end();
						Type *ty = (--op)->get()->getType();

						Type *ty2 = nullptr;
          	if (auto *pBCOp = dyn_cast<BitCastOperator>(op)) {
							//errs() << "pCI->dump(): "; pCI->dump();
							//errs() << "pBCOp->dump(): "; pBCOp->dump();
							ty2 = pBCOp->getOperand(0)->getType();
						}

						if (!edge_map[caller])
							edge_map[caller] = new set<Function *>;

						unsigned num = 0;
						for (auto &F2: M) {
							if (&F2 && F2.isDeclaration()) {
								bool match = false;
								for (auto x: black_set) {
									if (F2.getName() == x) {
										match = true;
										//errs() << "pF->getName(): " << pF->getName() << "\n";
										break;
									}
								}

								if (match)
									continue;
							}

							//if (&F2 && !F2.isDeclaration() && F2.getType() == ty)
							if (&F2 && F2.getType() == ty) {
								edge_map[caller]->insert(&F2);
								num++;
							} else if (ty2 && F2.getType() == ty2) {
								edge_map[caller]->insert(&F2);
								num++;
							}
						}

						//errs() << "num: " << num << "\n";
						if (statMaxNumCalleePerCall < num)
							statMaxNumCalleePerCall = num;
						statNumIndirectCall++;
					}
				}
			}
		}
	}

	for (auto edge: edge_map) {
		Function *caller = edge.first;
		set<Function *>* callees = edge.second;

		auto &BB = main->front();
		auto &I = BB.front();
		IRBuilder<> Builder(&I);
		//errs() << "-- Caller: " << caller->getName() << "\n";
		//errs() << "-- Caller[" << callees->size() << "] " << caller->getName() << "\n";
		if (statMaxNumCallee < callees->size())
			statMaxNumCallee = callees->size();

		for (auto callee: *callees) {
			//errs() << "---- Callee: " << callee->getName() << "\n";
			// Insert tagc rd, x0, rs1
			FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C)}, false);
			auto tagc = QEMU? M.getOrInsertFunction("__tagc", FuncTypeA) :
												Intrinsic::getDeclaration(&M, Intrinsic::cpt_tagc, {Type::getInt8PtrTy(*C)});
			auto castA = Builder.CreateCast(Instruction::BitCast, callee, Type::getInt8PtrTy(*C));
			auto castB = Builder.CreateCast(Instruction::BitCast, caller, Type::getInt8PtrTy(*C));
			auto callA = Builder.CreateCall(tagc, {castA, castB}, "");

			// Insert estr
			FunctionType *FuncTypeB = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C)}, false);
			auto estr = QEMU? M.getOrInsertFunction("__estr", FuncTypeB) :
												Intrinsic::getDeclaration(&M, Intrinsic::cpt_estr);
			auto callB = Builder.CreateCall(estr, {callA}, "");
			statNumESTR++;
			//callB->dump();
		}
	}
}

void CodePtrTagPass::handleFunctions(Module &M) {
	for (auto &F : M) {
		if (CptNode *node = value_map[&F]) {
			//printNode(node);

			bool chk = false;
			for (auto it = node->aliases.begin(); it != node->aliases.end(); it++) {
				//errs() << "--Print an alias!\n";
				Value *pV = it->first;
				if (Function *pF = dyn_cast<Function>(pV)) {
					chk = true;
					errs() << pF->getName() << "\n";
				}
			}

			if (chk) {
				errs() << "Func alias not found!\n";
			}
		}
	}
}

void CodePtrTagPass::handleIndirectCalls(Module &M) {
	set <CallInst *> call_set;

	for (auto &F : M) {
    //errs() << "F.getName(): " << F.getName() << "\n";
		for (auto &BB : F) {
			for (auto &I : BB) {
				if (CallInst *pCI = dyn_cast<CallInst>(&I)) {
        	Function *pF = pCI->getCalledFunction();
					if (!pF) {
						Function *caller = pCI->getFunction();
						auto op = pCI->op_end();
						auto pV = (--op)->get();
						Type *ty = pV->getType();

						bool chk = false;
						for (auto &F2: M) {
							if (&F2 && !F2.isDeclaration() && F2.getType() == ty) {
								chk = true;
								break;
							}
						}

						if (chk)
							call_set.insert(pCI);

						if (CptNode *node = value_map[pV]) {
							//printNode(node);

							errs() << "====================\n";
							bool chk = false;
							for (auto it = node->aliases.begin(); it != node->aliases.end(); it++) {
								//errs() << "--Print an alias!\n";
								Value *pV = it->first;
								if (Function *pF = dyn_cast<Function>(pV)) {
									chk = true;
									errs() << pF->getName() << "\n";
								}
							}

							if (!chk) {
								errs() << "Func alias not found!\n";
							}

							errs() << "====================\n\n";
						}
					}
				}
			}
		}
	}

	for (auto pCI: call_set)
		handleIndirectCall(M, pCI);
}

void CodePtrTagPass::handleIndirectCall(Module &M, CallInst *pCI) {
	Function *caller = pCI->getFunction();
	Value* callee = pCI->getCalledValue();
	IRBuilder<> Builder(pCI);

	// Insert tagc rd, rs1, rs2
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
  Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), temp_cnt++);
	auto tagc = QEMU? M.getOrInsertFunction("__tagc", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::cpt_tagc, {Type::getInt8PtrTy(*C)});
	auto castA = Builder.CreateCast(Instruction::BitCast, callee, Type::getInt8PtrTy(*C));
	auto castB = Builder.CreateCast(Instruction::BitCast, caller, Type::getInt8PtrTy(*C));
	if (QEMU) {
		auto callA = Builder.CreateCall(tagc, {castA, castB, arg}, "");
	} else {
		auto callA = Builder.CreateCall(tagc, {castA, castB}, "");
		auto castC = Builder.CreateCast(Instruction::BitCast, callA, callee->getType());
		unsigned int i = 0;
		while (true) {
			auto pV = pCI->getOperand(i);
			if (pV == callee) {
				pCI->setOperand(i, castC);
				break;
			}
			i++;
		}
	}
}

void CodePtrTagPass::printNode(CptNode *node) {
	//errs() << node << "\n";
	//errs() << "--Print indices!\n";
	//for (auto it = node->indices.begin(); it != node->indices.end(); it++) {
	//	(*it)->dump();
	//}

	for (auto it = node->aliases.begin(); it != node->aliases.end(); it++) {
  	errs() << "--Print an alias!\n";
    Value *pV = it->first;
    pV->dump();

  	errs() << "----Print uses of the alias!\n";
    for (auto pU: pV->users()) {
      if (Instruction *pI = dyn_cast<Instruction>(pU)) {
        pI->dump();
      }
    }
	}
}

void CodePtrTagPass::init(Module &M) {
	for (auto &F : M) {
		if (&F && F.getName() == "main") {
		  C = &F.getContext();
			DL = &F.getParent()->getDataLayout();
			main = &F;
			return;
		}
	}

	for (auto &F : M) {
		if (&F) {
		  C = &F.getContext();
			DL = &F.getParent()->getDataLayout();

			return;
		}
	}
}

void CodePtrTagPass::printFuncAddr(Module &M) {
	auto &BB = main->front();
	auto &I = BB.front();
	IRBuilder<> Builder(&I);

	for (auto &F2 : M) {
		if (&F2 && !F2.isDeclaration()) {
			Constant *name = ConstantDataArray::getString(*C, F2.getName(), true);

			GlobalVariable* pGV = new GlobalVariable(M, 
        /*Type=*/ name->getType(),
        /*isConstant=*/ true,
        /*Linkage=*/ GlobalValue::PrivateLinkage,
        /*Initializer=*/ 0, // has initializer, specified below
        /*Name=*/ ".func_name");
			pGV->setAlignment(1);
			pGV->setInitializer(name);

			auto castA = Builder.CreateCast(Instruction::BitCast, pGV, Type::getInt8PtrTy(*C));
			auto castB = Builder.CreateCast(Instruction::BitCast, &F2, Type::getInt8PtrTy(*C));
			FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C)}, false);
			auto init = M.getOrInsertFunction("__print_func", FuncTypeA);
			Builder.CreateCall(init, {castA, castB});
		}
	}
}

void CodePtrTagPass::insertCptSet(Module &M, int enable) {
  //for (auto &F : M) {
  //  if (&F && !F.isDeclaration()) {
  //    auto &BB = F.front();
  //    auto &I = BB.front();
  //    IRBuilder<> Builder(&I);

  //    Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), func_num++);
  //    FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(M.getContext())}, false);
  //    auto print = F.getParent()->getOrInsertFunction("dpt_print_func", FuncTypeA);
  //    Builder.CreateCall(print, {arg});

	//		for (auto &BB: F) {
	//			for (auto &I: BB) {
	//				if (dyn_cast<ReturnInst>(&I)) {
	//					IRBuilder<> BuilderB(&I);

	//					Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), func_num-1);
	//					FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(M.getContext())}, false);
	//					auto print = F.getParent()->getOrInsertFunction("dpt_print_func_ret", FuncTypeA);
	//					BuilderB.CreateCall(print, {arg});
	//					break;
	//				}
	//			}
	//		}

  //  }
  //}

	// Insert cpt_set() to init configuration
	bool chk = false;
	for (auto &F : M) {
		if (&F && F.getSection().find(".text.startup") != std::string::npos) {
			//errs() << "Found startup function: " << F.getName() << "\n";
			auto &BB = F.front();
			auto &I = BB.front();
			IRBuilder<> Builder(&I);

			Value *num = ConstantInt::get(Type::getInt64Ty(*C), enable);
			FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(*C)}, false);
			auto init = M.getOrInsertFunction("__cpt_set", FuncTypeA);
			Builder.CreateCall(init, {num});
			chk = true;
			break;
		}
	}

	// if startup function is found, cpt_set already inserted
	if (chk)
		return;

	for (auto &F : M) {
		if (&F && F.getName() == "main") {
			auto &BB = F.front();
			auto &I = BB.front();
			IRBuilder<> Builder(&I);

			Value *num = ConstantInt::get(Type::getInt64Ty(*C), enable);
			FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(*C)}, false);
			auto init = M.getOrInsertFunction("__cpt_set", FuncTypeA);
			Builder.CreateCall(init, {num});
			break;
		}
	}	
}
