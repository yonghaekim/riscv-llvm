#include "llvm/CPT/CodePtrTagPass.h"
#include "llvm/CPT/CPT.h"

#define PARTS_USE_SHA3

extern "C" {
#include "../PARTS-sha3/include/sha3.h"
}

#define ASSERT(x) if (!(x)) *(voidptr) = 0;

char CodePtrTagPass::ID = 0;
static RegisterPass<CodePtrTagPass> X("cpt-tag", "Code-pointer tagging pass");

Pass *llvm::CPT::createCodePtrTagPass() { return new CodePtrTagPass(); }

bool CodePtrTagPass::runOnModule(Module &M) {
	init(M);
  auto const cptInstType = llvm::CPT::getCptInstType();
  auto const cptQemuMode = llvm::CPT::getCptQemuMode();

  if (cptInstType == CptType::None) {
		insertCptSet(M);
	  return false;
	}

	errs() << "Start CPT pass!\n";

	CPT = (cptInstType == CptType::CPT);
	QEMU = (cptQemuMode == CptQemuEn::Enable);
	ASSERT(CPT);

	FuncTypeCfgPass &MT = getAnalysis<FuncTypeCfgPass>();
	label_map = MT.getLabelMap();

  //initBlackSet();
	//findWhiteSet(M);
  //findTypeAlias(M);
	//initLabelMap(M);
	handleGlobalVariables(M);
	replaceUsers(M);
	handleIndirectCalls(M);
	//handleIntrinsicFunctions(M);

	if (QEMU)
	  printFuncAddr(M);
	insertCptSet(M);

	errs() << "Size of white set: " << white_set.size() << "\n";
	errs() << "statNumIndirectCall: " << statNumIndirectCall << "\n";
	errs() << "statNumESTR: " << statNumESTR << "\n";
	errs() << "statMaxEqClassSize: " << statMaxEqClassSize << "\n";

	return true; // function_modified = true
}

void CodePtrTagPass::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesAll();
  AU.addRequired<FuncTypeCfgPass> ();
}

void CodePtrTagPass::initBlackSet() {
	black_set.insert("llvm.va_start");
	black_set.insert("llvm.va_end");
	black_set.insert("llvm.lifetime.start.p0i8");
	black_set.insert("llvm.lifetime.end.p0i8");
	black_set.insert("llvm.dbg.declare");
	black_set.insert("llvm.dbg.label");
	black_set.insert("llvm.prefetch");
	black_set.insert("llvm.stacksave");
	black_set.insert("llvm.stackrestore");
	black_set.insert("llvm.floor.f64");
	black_set.insert("llvm.floor.f32");
	black_set.insert("llvm.ceil.f64");
	black_set.insert("llvm.ceil.f32");
	black_set.insert("llvm.fabs.f64");
	black_set.insert("llvm.fabs.f32");
	black_set.insert("llvm.va_copy");
	black_set.insert("llvm.round.f64");
	black_set.insert("llvm.trap");
}

void CodePtrTagPass::findWhiteSet(Module &M) {
	for (auto &F: M) {
		bool match = false;
		for (auto x: black_set) {
			if (F.getName() == x) {
				match = true;
				break;
			}
		}

		if (match)
			continue;

    // No need to include startup code
		if (F.getSection().find(".text.startup") != std::string::npos)
      continue;

		//errs() << "F.getName(): " << F.getName() << "\n";
		auto pV = &F;

		for (auto pU: pV->users()) {
			if (auto pSI = dyn_cast<StoreInst>(pU)) {
				if (pSI->getValueOperand() == &F) {
					//errs() << "Found store! "; pSI->dump();
					white_set.insert(&F);
				}
			} else if (auto pCI = dyn_cast<CallInst>(pU)) {
				if (pCI->getCalledFunction() != pV) {
					//errs() << "Found call! "; pCI->dump();
					white_set.insert(&F);
				}
			} else if (auto pII = dyn_cast<InvokeInst>(pU)) {
				if (pII->getCalledFunction() != pV) {
					//errs() << "Found call! "; pCI->dump();
					white_set.insert(&F);
				}
			} else if (auto pSI = dyn_cast<SelectInst>(pU)) {
				white_set.insert(&F);
			} else if (auto pPN = dyn_cast<PHINode>(pU)) {
				white_set.insert(&F);
			} else if (auto pGV = dyn_cast<GlobalVariable>(pU)) {
				//errs() << "Found GV! "; pGV->dump();
				white_set.insert(&F);
			} else if (auto pBC = dyn_cast<BitCastOperator>(pU)) {
				//errs() << "Found BC! "; pBC->dump();
				white_set.insert(&F);
			} else if (auto pConst = dyn_cast<Constant>(pU)) {
				//errs() << "Found Const! "; pConst->dump();
				white_set.insert(&F);
			}
		}
	}

	errs() << "Size of white set: " << white_set.size() << "\n";
	for (auto pV: white_set) {
		if (auto pF = dyn_cast<Function>(pV)) {
			errs() << "--" << pF->getName() << "\n";
		}
	}
}

void CodePtrTagPass::replaceUsers(Module &M) {
	map<Function*,set<Instruction*>*> replace_map;
	map<Function*,set<BitCastOperator*>*> bitcast_map;
	map<Function*,set<PtrToIntOperator*>*> ptrtoint_map;
	map<Function*,set<PHINode*>*> phinode_map;

	for (auto pF: white_set) {
		//errs() << "pF->getName(): " << pF->getName() << "\n";
		if (!replace_map[pF])
			replace_map[pF] = new set<Instruction*>;
		if (!bitcast_map[pF])
			bitcast_map[pF] = new set<BitCastOperator*>;
		if (!ptrtoint_map[pF])
			ptrtoint_map[pF] = new set<PtrToIntOperator*>;
		if (!phinode_map[pF])
			phinode_map[pF] = new set<PHINode*>;

		for (auto pU: pF->users()) {
			if (auto pI = dyn_cast<Instruction>(pU)) {
				if (auto pSI = dyn_cast<StoreInst>(pI)) {
					if (pSI->getValueOperand() == pF) {
						replace_map[pF]->insert(pI);
					}
				} else if (auto pCI = dyn_cast<CallInst>(pI)) {
					if (pCI->getCalledFunction() != pF) {
						replace_map[pF]->insert(pI);
					}
				} else if (auto pII = dyn_cast<InvokeInst>(pI)) {
					if (pII->getCalledFunction() != pF) {
						replace_map[pF]->insert(pI);
					}
				} else if (auto pBC = dyn_cast<BitCastInst>(pI)) {
					ASSERT(false); // 
				} else if (auto pSI = dyn_cast<SelectInst>(pI)) {
					//errs() << "Found SelectInst: "; pI->dump();
					replace_map[pF]->insert(pI);
				} else if (auto pCI = dyn_cast<ICmpInst>(pU)) {
					// Do nothing
				} else if (auto pPN = dyn_cast<PHINode>(pI)) {
					phinode_map[pF]->insert(pPN);
				} else {
					//TODO
					errs() << "else pI->dump(): "; pI->dump();
				}
			} else if (auto pGV = dyn_cast<GlobalVariable>(pU)) {
				//TODO
			} else if (auto pPTI = dyn_cast<PtrToIntOperator>(pU)) {
				errs() << "(a) Found PtrToIntOperator! "; pPTI->dump();
				ptrtoint_map[pF]->insert(pPTI);
			} else if (auto pBC = dyn_cast<BitCastOperator>(pU)) {
				//errs() << "Found BC! "; pBC->dump();
				bitcast_map[pF]->insert(pBC);
				//handleBitCastOperator(M, pBC, pF);
			} else if (auto pConst = dyn_cast<Constant>(pU)) {
			} else {
				errs() << "pU->dump(): "; pU->dump();
			}
		}
	}

	for (auto x: replace_map) {
		Function *pF = x.first;
		for (auto pI: *(x.second)) {
			replaceUser(M, pI, pF, pF);
		}
	}

	for (auto x: bitcast_map) {
		Function *pF = x.first;
		for (auto pBC: *(x.second)) {
			handleBitCastOperator(M, pBC, pF);
		}
	}

	for (auto x: ptrtoint_map) {
		Function *pF = x.first;
		for (auto pPTI: *(x.second)) {
			handlePtrToIntOperator(M, pPTI, pF);
		}
	}

	for (auto x: phinode_map) {
		Function *pF = x.first;
		for (auto pPN: *(x.second)) {
			handlePHINode(M, pPN, pF, pF);
		}
	}
}

void CodePtrTagPass::replaceUser(Module &M, Instruction *pI, Value *pV, Value *pF) {
	u_int16_t label = label_map[dyn_cast<Function>(pF)];
	if (label != 0) {
		IRBuilder<> Builder(pI);
		Instruction *callA = insertTagc(M, &Builder, pV, pF);
		insertEact(M, &Builder, callA, label);
		auto castA = Builder.CreateCast(Instruction::BitCast, callA, pV->getType());
		replaceOp(pV, castA, pI);
	} else {
		//ASSERT(false);
	}
}

Instruction *CodePtrTagPass::insertTagc(Module &M, IRBuilder<> *Builder, Value *pV, Value *pF) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	Value *argA = ConstantInt::get(Type::getInt64Ty(*C), 0);

  auto typeIdConstant = getTypeIDConstantFrom(*(pF->getType()), *C);

	if (pV->getType()->isPointerTy()) {
		auto castA = Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C));
		auto tagc = QEMU? M.getOrInsertFunction("__tagc", FuncTypeA) :
											Intrinsic::getDeclaration(&M, Intrinsic::cpt_tagc, {Type::getInt8PtrTy(*C)});
		auto callA = Builder->CreateCall(tagc, {castA, typeIdConstant}, "");
		return callA;
	} else {
		auto castA = Builder->CreateIntToPtr(pV, Type::getInt8PtrTy(*C));
		auto tagc = QEMU? M.getOrInsertFunction("__tagc", FuncTypeA) :
											Intrinsic::getDeclaration(&M, Intrinsic::cpt_tagc, {Type::getInt8PtrTy(*C)});
		auto callA = Builder->CreateCall(tagc, {castA, typeIdConstant}, "");

		return callA;
	}
}

Instruction *CodePtrTagPass::insertXtag(Module &M, IRBuilder<> *Builder, Value *pV) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C)}, false);

	if (pV->getType()->isPointerTy()) {
		auto castA = Builder->CreateCast(Instruction::BitCast, pV, Type::getInt8PtrTy(*C));
		auto xtag = M.getOrInsertFunction("__xtag", FuncTypeA);
		//auto xtag = QEMU? M.getOrInsertFunction("__xtag", FuncTypeA) :
		//									Intrinsic::getDeclaration(&M, Intrinsic::cpt_xtag, {Type::getInt8PtrTy(*C)});
		auto callA = Builder->CreateCall(xtag, {castA}, "");
		return callA;
	} else {
		auto castA = Builder->CreateIntToPtr(pV, Type::getInt8PtrTy(*C));
		auto xtag = M.getOrInsertFunction("__xtag", FuncTypeA);
		//auto xtag = QEMU? M.getOrInsertFunction("__xtag", FuncTypeA) :
		//									Intrinsic::getDeclaration(&M, Intrinsic::cpt_xtag, {Type::getInt8PtrTy(*C)});
		auto callA = Builder->CreateCall(xtag, {castA}, "");
		return callA;
	}
}

void CodePtrTagPass::insertEact(Module &M, IRBuilder<> *Builder, Value *pV, size_t label) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	Value *argB = ConstantInt::get(Type::getInt64Ty(*C), label);
	auto eact = QEMU? M.getOrInsertFunction("__eact", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::cpt_eact);
	Builder->CreateCall(eact, {pV, argB}, "");
}

void CodePtrTagPass::insertEstr(Module &M, IRBuilder<> *Builder, Value *pV, size_t label) {
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	Value *argB = ConstantInt::get(Type::getInt64Ty(*C), label);
	auto estr = QEMU? M.getOrInsertFunction("__estr", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::cpt_estr);
	Builder->CreateCall(estr, {pV, argB}, "");
}

void CodePtrTagPass::replaceOp(Value *pVa, Value *pVb, Instruction *pI) {
	//errs() << "pVa->dump(): "; pVa->dump();
	//errs() << "pVb->dump(): "; pVb->dump();
	//errs() << "pI->dump(): "; pI->dump();
	unsigned nth = 0;
	bool chk = false;
	for (auto op = pI->op_begin(); op != pI->op_end(); op++) {
		if (auto *_pVa = dyn_cast<Value>(op)) {
			if (_pVa == pVa) {
				pI->setOperand(nth, pVb);
				//errs() << "(2) pI->dump(): "; pI->dump();
				chk = true;
				//break;
			}
		}

		nth++;
	}

	//errs() << "(3) pI->dump(): "; pI->dump();

	ASSERT(chk);
}

void CodePtrTagPass::handleBitCastOperator(Module &M, BitCastOperator *pBC, Function *pF) {
	map<Value*,set<Instruction*>*> replace_map;
	set<PHINode*> phinode_set;

	if (!replace_map[pBC])
		replace_map[pBC] = new set<Instruction*>;

	for (auto pU: pBC->users()) {
		//errs() << "pU->dump(): "; pU->dump();
		if (auto pI = dyn_cast<Instruction>(pU)) {
			if (auto pSI = dyn_cast<StoreInst>(pI)) {
				if (pSI->getValueOperand() == pBC) {
					replace_map[pBC]->insert(pI);
					//replaceUser(M, pSI, pF);
				}
			} else if (auto pCI = dyn_cast<CallInst>(pI)) {
				if (pCI->getCalledFunction() != dyn_cast<Function>(pBC)) {
					replace_map[pBC]->insert(pI);
					//replaceUser(M, pI, pBC);
				}
			} else if (auto pII = dyn_cast<InvokeInst>(pI)) {
				if (pII->getCalledFunction() != dyn_cast<Function>(pBC)) {
					replace_map[pBC]->insert(pI);
					//replaceUser(M, pI, pBC);
				}
			} else if (auto pSI = dyn_cast<SelectInst>(pI)) {
				//errs() << "Found SelectInst: "; pI->dump();
				replace_map[pBC]->insert(pI);
			} else if (auto pPN = dyn_cast<PHINode>(pI)) {
				phinode_set.insert(pPN);
			} else {
				errs() << "(4) pI->dump(): "; pI->dump();
			}
		} else if (auto pGV = dyn_cast<GlobalVariable>(pU)) {
			//errs() << "Found GV! "; pGV->dump();
			//handleGlobalFuncPtr(M, pGV, pBC);
		} else if (auto pPTI = dyn_cast<PtrToIntOperator>(pU)) {
			errs() << "(b) Found PtrToIntOperator! "; pPTI->dump();
			//TODO
		} else if (auto pConst = dyn_cast<Constant>(pU)) {
			//handleConstant(M, pConst, pBC);
		} else {
			errs() << "(a) pU->dump(): "; pU->dump();
		}
	}

	for (auto x: replace_map) {
		Value *pV = x.first;
		for (auto pI: *(x.second)) {
			replaceUser(M, pI, pV, pF);
		}
	}

	for (auto pPN: phinode_set) {
		handlePHINode(M, pPN, pBC, pF);
	}
}

void CodePtrTagPass::handlePtrToIntOperator(Module &M, PtrToIntOperator *pPTI, Function *pF) {
	set<Instruction*> inst_set;
	set<PHINode*> phinode_set;
	map<Constant*, set<Instruction*>*> const_map;

	for (auto pU: pPTI->users()) {
		if (auto pI = dyn_cast<Instruction>(pU)) {
			if (auto pSI = dyn_cast<StoreInst>(pI)) {
				if (pSI->getValueOperand() == pPTI) {
					inst_set.insert(pI);
				}
			} else if (auto pBC = dyn_cast<BitCastInst>(pI)) {
				ASSERT(false); // 
			} else if (auto pSI = dyn_cast<SelectInst>(pI)) {
				inst_set.insert(pI);
			} else if (auto pCI = dyn_cast<ICmpInst>(pI)) {
				// Do nothing
			} else if (auto pPN = dyn_cast<PHINode>(pI)) {
				errs() << "Found PHINode user of pPTI\n";
				phinode_set.insert(pPN);
			} else {
				//TODO
				errs() << "else pI->dump(): "; pI->dump();
			}
		} else if (auto pConst = dyn_cast<Constant>(pU)) {
			if (!const_map[pConst])
				const_map[pConst] = new set<Instruction*>;

			errs() << "pConst->dump(): "; pConst->dump();
			if (pConst->getType()->isArrayTy() || pConst->getType()->isStructTy()) {
				errs() << "(2) pConst->dump(): "; pConst->dump();
				for (auto pU2: pConst->users()) {
					if (auto pI2 = dyn_cast<Instruction>(pU2)) {
						const_map[pConst]->insert(pI2);
						//errs() << "pI2->dump(): "; pI2->dump();
					}
				}
			} else {
			}
		}
	}

	for (auto pI: inst_set) {
		u_int16_t label = label_map[dyn_cast<Function>(pF)];
		if (label != 0) {
			IRBuilder<> Builder(pI);
			Instruction *callA = insertTagc(M, &Builder, pF, pF);
			insertEact(M, &Builder, callA, label);
			auto castB = Builder.CreatePtrToInt(callA, pPTI->getType());
			replaceOp(pPTI, castB, pI);
		} else {
			//ASSERT(false);
		}
	}

	for (auto pPN: phinode_set) {
		handlePHINode(M, pPN, pPTI, pF);
	}

	for (auto x: const_map) {
		Constant *pConst = x.first;
		for (auto pI: *(x.second)) {
			u_int16_t label = label_map[dyn_cast<Function>(pF)];
			if (label != 0) {
				// TODO is first arg or second?
				IRBuilder<> Builder(pI);
				Instruction *callA = insertTagc(M, &Builder, pF, pF);
				insertEact(M, &Builder, callA, label);

				auto castB = Builder.CreatePtrToInt(callA, pPTI->getType());
				auto undef = UndefValue::get(pConst->getType());
				auto extract = Builder.CreateExtractValue(pConst, 1);
				auto insert = Builder.CreateInsertValue(undef, castB, 0);
				auto insert2 = Builder.CreateInsertValue(insert, extract, 1);

				replaceOp(pConst, insert2, pI);
			} else {
				//ASSERT(false);
			}
		}
	}
}

void CodePtrTagPass::handlePHINode(Module &M, PHINode *pPN, Value *pV, Value *pF) {
	//errs() << "Found PHINode: "; pPN->dump();
	unsigned num = pPN->getNumIncomingValues();
	for (unsigned i=0; i<num; i++) {
		if (pPN->getIncomingValue(i) == pV) {
			auto pBB = pPN->getIncomingBlock(i);
			auto &I = pBB->back();

			u_int16_t label = label_map[dyn_cast<Function>(pF)];
			if (label != 0) {
				IRBuilder<> Builder(&I);
				Instruction *callA = insertTagc(M, &Builder, pV, pF);
				insertEact(M, &Builder, callA, label);

				if (pV->getType()->isPointerTy()) {
					auto castA = Builder.CreateCast(Instruction::BitCast, callA, pV->getType());
					pPN->setIncomingValue(i, castA);
				} else {
					auto castA = Builder.CreatePtrToInt(callA, pV->getType());
					pPN->setIncomingValue(i, castA);
				}
			} else {
				//ASSERT(false);
			}
		}
	}
}

void CodePtrTagPass::handleGlobalVariables(Module &M) {
	set<GlobalVariable*> gv_set;

	for (auto &G : M.getGlobalList()) {
		GlobalVariable *pGV = dyn_cast<GlobalVariable>(&G);

		//errs() << "(a) pGV->dump(): "; pGV->dump();
		if (pGV->getName().find(".str") != 0 && pGV->hasInitializer()) {
			gv_set.insert(pGV);
		}
  }

	for (auto pGV: gv_set) {
		//errs() << "pGV->dump(): "; pGV->dump();
		handleGlobalVariable(M, pGV);
	}
}

void CodePtrTagPass::handleGlobalVariable(Module &M, GlobalVariable *pGV) {
	Constant *pConst = pGV->getInitializer();
	Type *ty = pConst->getType();

	vector<Value*> *indices = new vector<Value*>;

	if (Function *pF = dyn_cast<Function>(pConst)) {
		if (white_set.find(pF) != white_set.end())
			handleFunctionTy(M, pF, pGV, indices, pF);
	} else if (auto *pBC = dyn_cast<BitCastOperator>(pConst)) {
		//errs() << "(1) BitCastOp pConst->dump(): "; pConst->dump();
		if (Function *pF = dyn_cast<Function>(pBC->getOperand(0))) {
			if (white_set.find(pF) != white_set.end())
				handleFunctionTy(M, pBC, pGV, indices, pF);
			//errs() << "(1) BitCastOp with Function Pointer pConst->dump(): "; pConst->dump();
		}
	} else if (ty->isArrayTy()) {
		indices->push_back(ConstantInt::get(Type::getInt64Ty(*C), 0));
		handleArrayTy(M, pConst, pGV, indices);
	} else if (ty->isStructTy()) {
		indices->push_back(ConstantInt::get(Type::getInt32Ty(*C), 0));
		handleStructTy(M, pConst, pGV, indices);
	} else if (ty->isPointerTy()) {
		//errs() << "(1) Pointer ty->dump(): "; ty->dump();
	} else {
		//errs() << "(1) else ty->dump(): "; ty->dump();
	}

	pGV->setConstant(false);

	delete indices;
}

void CodePtrTagPass::handleFunctionTy(Module &M, Value *pV, GlobalVariable *pGV, vector<Value*> *indices, Value *pF) {
	//errs() << "Handle Function: " << pF->getName() << "\n";
	auto &BB = entry->front();
	auto &I = BB.back();
	IRBuilder<> Builder(&I);

	//errs() << "pGV->dump(): "; pGV->dump();
	//for (auto x: *indices) {
	//	x->dump();
	//}

	u_int16_t label = label_map[dyn_cast<Function>(pF)];
	if (label != 0) {
		Instruction *callA = insertTagc(M, &Builder, pV, pF);
		insertEact(M, &Builder, callA, label);
		auto castB = Builder.CreateCast(Instruction::BitCast, callA, pV->getType());

		auto gep = Builder.CreateGEP(pGV, *indices);
		auto store = Builder.CreateStore(castB, gep);
		store->setAlignment(8);
	} else {
		//ASSERT(false);
	}
	//errs() << "gep->dump(): "; gep->dump();
	//errs() << "store->dump(): "; store->dump();
}

void CodePtrTagPass::handleArrayTy(Module &M, Constant *pConst, GlobalVariable *pGV, vector<Value*> *indices) {
	Type *ty = pConst->getType();
	unsigned n = ty->getArrayNumElements();
	Type *_ty = ty->getArrayElementType();
	//errs() << "pConst->dump(): "; pConst->dump();
	//errs() << "Handle Array Ty(" << n << "): "; ty->dump();

	for (unsigned i=0; i<n; i++) {
		Constant *_pConst = pConst->getAggregateElement(i);
		vector<Value*> *indices_new = new vector<Value*>;
		//errs() << "Array[" << i << "] Aggregate Element\n";
		//errs() << "_pConst->dump(): "; _pConst->dump();

		// Copy indices
		for (auto pV: *indices)
			indices_new->push_back(pV);

		indices_new->push_back(ConstantInt::get(Type::getInt64Ty(*C), i));

		// Check element type
		if (auto *_pF = dyn_cast<Function>(_pConst)) {
			if (white_set.find(_pF) != white_set.end())
				handleFunctionTy(M, _pF, pGV, indices_new, _pF);
		} else if (auto *_pGA = dyn_cast<GlobalAlias>(_pConst)) {
			if (auto *_pF = dyn_cast<Function>(_pGA->getAliasee())) {
				if (white_set.find(_pF) != white_set.end())
					handleFunctionTy(M, _pGA, pGV, indices_new, _pF);
				errs() << "(1) Found!!!\n";
			}
		} else if (auto *_pBC = dyn_cast<BitCastOperator>(_pConst)) {
			if (auto *_pF = dyn_cast<Function>(_pBC->getOperand(0))) {
				if (white_set.find(_pF) != white_set.end())
					handleFunctionTy(M, _pBC, pGV, indices_new, _pF);
			} else if (auto *_pGA = dyn_cast<GlobalAlias>(_pBC->getOperand(0))) {
				if (auto *_pF = dyn_cast<Function>(_pGA->getAliasee())) {
					if (white_set.find(_pF) != white_set.end())
						handleFunctionTy(M, _pBC, pGV, indices_new, _pF);
					errs() << "(2) Found!!!\n";
				}
			}
		} else if (_ty->isArrayTy()) {
			handleArrayTy(M, _pConst, pGV, indices_new);
		} else if (_ty->isStructTy()) {
			handleStructTy(M, _pConst, pGV, indices_new);
		} else {
			//errs() << "(1) else _ty->dump(): "; _ty->dump();
		}

		delete indices_new;
	}
}

void CodePtrTagPass::handleStructTy(Module &M, Constant *pConst, GlobalVariable *pGV, vector<Value*> *indices) {
	Type *ty = pConst->getType();
	unsigned n = dyn_cast<StructType>(ty)->getNumElements();
	//errs() << "pConst->dump(): "; pConst->dump();
	//errs() << "Handle Struct Ty(n:" << n << "): "; ty->dump();

	for (unsigned i=0; i<n; i++) {
		Constant *_pConst = pConst->getAggregateElement(i);
		Type *_ty = dyn_cast<StructType>(ty)->getElementType(i);
		vector<Value*> *indices_new = new vector<Value*>;
		//errs() << "Struct[" << i << "] Aggregate Element\n";
		//errs() << "_pConst->dump(): "; _pConst->dump();
		//errs() << "_ty->dump(): "; _ty->dump();

		// Copy indices
		for (auto pV: *indices)
			indices_new->push_back(pV);

		indices_new->push_back(ConstantInt::get(Type::getInt32Ty(*C), i));

		// Check element type
		if (Function *_pF = dyn_cast<Function>(_pConst)) {
			if (white_set.find(_pF) != white_set.end())
				handleFunctionTy(M, _pF, pGV, indices_new, _pF);
		} else if (auto *_pGA = dyn_cast<GlobalAlias>(_pConst)) {
			if (auto *_pF = dyn_cast<Function>(_pGA->getAliasee())) {
				if (white_set.find(_pF) != white_set.end())
					handleFunctionTy(M, _pGA, pGV, indices_new, _pF);
				errs() << "(3) Found!!!\n";
			}
		} else if (auto *_pBC = dyn_cast<BitCastOperator>(_pConst)) {
			if (Function *_pF = dyn_cast<Function>(_pBC->getOperand(0))) {
				if (white_set.find(_pF) != white_set.end())
					handleFunctionTy(M, _pBC, pGV, indices_new, _pF);
			} else if (auto *_pGA = dyn_cast<GlobalAlias>(_pBC->getOperand(0))) {
				if (auto *_pF = dyn_cast<Function>(_pGA->getAliasee())) {
					if (white_set.find(_pF) != white_set.end())
						handleFunctionTy(M, _pBC, pGV, indices_new, _pF);
					errs() << "(4) Found!!!\n";
				}
			}
		} else if (_ty->isArrayTy()) {
			handleArrayTy(M, _pConst, pGV, indices_new);
		} else if (_ty->isStructTy()) {
			handleStructTy(M, _pConst, pGV, indices_new);
		//} else if (_ty->isPointerTy()) {
		} else {
			//errs() << "(2) else _ty->dump(): "; _ty->dump();
		}

		delete indices_new;
	}
}

void CodePtrTagPass::findTypeAlias(Module &M) {
	// Find struct type alias...
	list<StructType*> sty_list;

	for (auto &sty: M.getIdentifiedStructTypes()) {
		sty_list.push_back(sty);
	}

	for (auto it = sty_list.begin(); it != sty_list.end(); it++) {
		StructType *sty0 = (*it);

		for (auto it2 = it; it2 != sty_list.end(); it2++) {
			StructType *sty1 = (*it2);

			if (sty0 == sty1)
				continue;

			bool check = false;
			if (sty0->isOpaque() || sty1->isOpaque() ||
					sty0->isLayoutIdentical(sty1)) {
				check = true;
			} else {
				auto name0 = sty0->getName();
				auto name1 = sty1->getName();
				size_t len0 = name0.size();
				size_t len1 = name1.size();
				const char *str0 = name0.data();
				const char *str1 = name1.data();

				size_t len = len0 < len1 ? len0 : len1;
				size_t i = 0;
				for (i=0; i<len; i++) {
					if (str0[i] != str1[i])
						break;
				}

				if (i == len)
					check = true;
			}
				//errs() << name0 << "'s size: " << name0.size() << "\n";
				//errs() << name1 << "'s size: " << name1.size() << "\n";
			if (check) {
				PointerType *pty0 = PointerType::get(sty0, 0);
				PointerType *pty1 = PointerType::get(sty1, 0);

				//errs() << "sty0->dump(): "; sty0->dump();
				//errs() << "sty1->dump(): "; sty1->dump();
				//errs() << "pty0->dump(): "; pty0->dump();
				//errs() << "pty1->dump(): "; pty1->dump();

				if (!type_alias[pty0]) {
					type_alias[pty0] = new set<Type*>;
					type_alias[pty0]->insert(pty0);
				}

				type_alias[pty0]->insert(pty1);

				if (!type_alias[pty1]) {
					type_alias[pty1] = new set<Type*>;
					type_alias[pty1]->insert(pty1);
				}

				type_alias[pty1]->insert(pty0);
			}
		}
	}


	// Find alias from bitcast
	for (auto &F: M) {
		for (auto pU: F.users()) {
			if (auto pBC = dyn_cast<BitCastOperator>(pU)) {
				Type *src_ty = pBC->getSrcTy();
				Type *dst_ty = pBC->getDestTy();

				addTypeAlias(src_ty, dst_ty);
			}
		}

		for (auto &BB: F) {
			for (auto &I: BB) {
				if (auto pBC = dyn_cast<BitCastInst>(&I)) {
					Type *src_ty = pBC->getSrcTy();
					Type *dst_ty = pBC->getDestTy();

					addTypeAlias(src_ty, dst_ty);
				}
			}
		}
	}

  // Add from white set
	for (auto x: white_set) {
		auto ty = x->getType();
		if (!type_alias[ty]) {
			type_alias[ty] = new set<Type*>;
			type_alias[ty]->insert(ty);
		}
	}

	// Add arg alias
	for (auto x: type_alias) {
		PointerType *pty0 = dyn_cast<PointerType>(x.first);

		if (pty0 == NULL)
			continue;

		Type *ety0 = pty0->getElementType();

		if (!ety0->isFunctionTy())
			continue;

		for (auto y: *(x.second)) {
			PointerType *pty1 = dyn_cast<PointerType>(y);

			if (pty1 == NULL)
				continue;

			Type *ety1 = pty1->getElementType();

			if (!ety1->isFunctionTy())
				continue;

			addArgAlias(ety0, ety1);
		}
	}

	set<Type*> visit_set;
	// Make union...
	for (auto x: type_alias) {
		Type *ty = x.first;

		if (visit_set.find(ty) != visit_set.end())
			continue;

		visit_set.insert(ty);

		set<Type*> alias_set;
		alias_set.insert(ty);

		list<Type*> type_list;
		type_list.push_back(ty);

		while (!type_list.empty()) {
			Type *_ty = type_list.front();
			type_list.pop_front();

			for (auto x: *type_alias[_ty]) {
				if (alias_set.find(x) == alias_set.end()) {
					type_list.push_back(x);
					alias_set.insert(x);
				}
			}
		}

		for (auto x: alias_set) {
			visit_set.insert(x);

			for (auto y: alias_set) {
				type_alias[x]->insert(y);
			}
		}
	}

	// Print type alias
	//for (auto x: type_alias) {
	//	auto ty = x.first;
	//	errs() << "Func Ty[" << (x.second)->size() << "]: "; ty->dump();

	//	for (auto y: *(x.second)) {
	//		errs() << "-- "; y->dump();
	//	}
	//}
}

void CodePtrTagPass::addTypeAlias(Type *src_ty, Type *dst_ty) {
	if (!src_ty->isPointerTy() || !dst_ty->isPointerTy()) {
		return;
	}

	PointerType *src_pty = dyn_cast<PointerType>(src_ty);
	PointerType *dst_pty = dyn_cast<PointerType>(dst_ty);

	if (!src_pty->getElementType()->isFunctionTy() &&
			!src_pty->getElementType()->isStructTy()) {
		//errs() << "(2) src_ty->dump(): "; src_ty->dump();
		//errs() << "(2) dst_ty->dump(): "; dst_ty->dump();
		//src_pty->getElementType()->dump();
		//dst_pty->getElementType()->dump();
		return;
	}

	if (!dst_pty->getElementType()->isFunctionTy() &&
			!dst_pty->getElementType()->isStructTy())
		return;

	if (!type_alias[src_ty]) {
		type_alias[src_ty] = new set<Type*>;
		type_alias[src_ty]->insert(src_ty);
	}

	type_alias[src_ty]->insert(dst_ty);

	if (!type_alias[dst_ty]) {
		type_alias[dst_ty] = new set<Type*>;
		type_alias[dst_ty]->insert(dst_ty);
	}

	for (auto ty: *type_alias[dst_ty]) {
		type_alias[src_ty]->insert(ty);
		type_alias[ty]->insert(src_ty);
	}

	type_alias[dst_ty]->insert(src_ty);

	for (auto ty: *type_alias[src_ty]) {
		type_alias[dst_ty]->insert(ty);
		type_alias[ty]->insert(dst_ty);
	}

	//errs() << "(1) src_ty->dump(): "; src_ty->dump();
	//errs() << "(1) dst_ty->dump(): "; dst_ty->dump();
}

void CodePtrTagPass::addArgAlias(Type *src_ety, Type *dst_ety) {
	FunctionType *src_fty = dyn_cast<FunctionType>(src_ety);
	FunctionType *dst_fty = dyn_cast<FunctionType>(dst_ety);

	if (src_fty->getNumParams() != dst_fty->getNumParams())
		return;

	unsigned params_num = src_fty->getNumParams();
	for (unsigned i=0; i<params_num; i++) {
		bool check = false;
		Type *ty0 = src_fty->getParamType(i);
		Type *ty1 = dst_fty->getParamType(i);

		PointerType *pty0 = dyn_cast<PointerType>(ty0);
		PointerType *pty1 = dyn_cast<PointerType>(ty1);

		if (pty0 == NULL || pty1 == NULL)
			continue;

		Type *ety0 = pty0->getElementType();
		Type *ety1 = pty1->getElementType();

		if (!ety0->isFunctionTy() && !ety0->isStructTy())
			continue;

		if (!ety1->isFunctionTy() && !ety1->isStructTy())
			continue;

		if (ety0 == ety1)
			continue;

		//errs() << "Found alias in arguments\n";
		//errs() << "pty0->dump(): "; pty0->dump();
		//errs() << "pty1->dump(): "; pty1->dump();

		if (!type_alias[pty0]) {
			type_alias[pty0] = new set<Type*>;
			type_alias[pty0]->insert(pty0);
		}

		if (!type_alias[pty1]) {
			type_alias[pty1] = new set<Type*>;
			type_alias[pty1]->insert(pty1);
		}

		type_alias[pty0]->insert(pty1);
		type_alias[pty1]->insert(pty0);
		//for (auto ty: *type_alias[pty0]) {
		//	type_alias[pty1]->insert(ty);
		//	type_alias[ty]->insert(pty1);
		//}

		////type_alias[dst_ty]->insert(src_ty);

		//for (auto ty: *type_alias[pty1]) {
		//	type_alias[pty0]->insert(ty);
		//	type_alias[ty]->insert(pty0);
		//}
	}
}

void CodePtrTagPass::initLabelMap(Module &M) {
	// Init label map
	for (auto &F: M) {
    // Skip startup code
		if (F.getSection().find(".text.startup") != std::string::npos)
      continue;

		if (white_set.find(&F) == white_set.end()) {
			//errs() << "Not found in white set: " << callee.getName() << "\n";
			continue;
		}

		label_map[&F] = 0;
	}

	for (std::map<Function*,u_int16_t>::iterator it1 = label_map.begin();
				it1 != label_map.end(); ++it1) {
		Function *pF1 = it1->first;
		u_int16_t label1 = it1->second;

		FunctionType *fty1 = pF1->getFunctionType();

		if (label1 == 0) {
			glb_label++;

			// Set label of function
			label_map[pF1] = glb_label;

			size_t eq_class_size = 1;

			errs() << "\n===============================\n";
			errs() << pF1->getName() << ": "; pF1->getType()->dump();

			for (auto x: *type_alias[pF1->getType()]) {
				PointerType *pty3 = dyn_cast<PointerType>(x);
				Type *ety3 = pty3->getElementType();
				if (!pty3 || !ety3->isFunctionTy())
					continue;

				FunctionType *fty3 = dyn_cast<FunctionType>(ety3);

				for (std::map<Function*,u_int16_t>::iterator it2 = it1;
							it2 != label_map.end(); ++it2) {

					Function *pF2 = it2->first;
					u_int16_t label2 = it2->second;

					if (label2 == 0) {
						FunctionType *fty2 = pF2->getFunctionType();

						if (doTypeComparison(fty3, fty2)) {
							label_map[pF2] = glb_label;
							eq_class_size++;
							errs() << pF2->getName() << ": "; pF2->getType()->dump();
						}
					}
				}
			}

			if (eq_class_size > statMaxEqClassSize)
				statMaxEqClassSize = eq_class_size;

			errs() << "===============================\n";
		}
	}

	auto &BB = entry->front();
	auto &I = BB.front();
	IRBuilder<> Builder(&I);

	FunctionType *FuncTypeA = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);
	FunctionType *FuncTypeB = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C)}, false);

	for (auto x: label_map) {
		Function *pF = x.first;
		u_int16_t label = x.second;

		// Insert tagd rd, rs1, rs2
		// Insert estr rs1, rs2
		Instruction *callA = insertTagc(M, &Builder, pF, pF);
		insertEstr(M, &Builder, callA, label);
		statNumESTR++;
	}
}

bool CodePtrTagPass::doTypeComparison(FunctionType *func_ty, FunctionType *callee_ty) {
	ASSERT(func_ty != NULL && callee_ty != NULL);

	// 0. Check exact match
	if (func_ty == callee_ty)
		return true;

	// 1. Check func type alias
	PointerType* func_pty = PointerType::get(func_ty, 0);
	PointerType* callee_pty = PointerType::get(callee_ty, 0);

	if (auto x = type_alias[func_pty]) {
	  for (auto y: *x) {
			//errs() << "alias->dump(): "; y->dump();
	    if (y == callee_pty) {
				return true;
			}
	  }
	}

	// 2. Check # params
	if (func_ty->getNumParams() != callee_ty->getNumParams())
		return false;

	// 3. Check return type
	//Type *func_ret = func_ty->getReturnType();
	//Type *callee_ret = callee_ty->getReturnType();

	//if (func_ret != callee_ret) {
	//	bool check = false;

	//	if (func_ret->isPointerTy() && callee_ret->isPointerTy()) {
	//		PointerType *pty0 = dyn_cast<PointerType>(func_ret);
	//		PointerType *pty1 = dyn_cast<PointerType>(callee_ret);
	//		Type *ety0 = pty0->getElementType();
	//		Type *ety1 = pty1->getElementType();

	//		if (ety0->isFunctionTy() || ety0->isStructTy()) {
	//			if (pty1 == Type::getInt8PtrTy(*C)) {
	//				errs() << "Found return alias type!\n";
	//				func_ret->dump();
	//				callee_ret->dump();
	//				check = true;
	//			}
	//		}

	//		if (ety1->isFunctionTy() || ety1->isStructTy()) {
	//			if (pty0 == Type::getInt8PtrTy(*C)) {
	//				errs() << "Found return alias type!\n";
	//				func_ret->dump();
	//				callee_ret->dump();
	//				check = true;
	//			}
	//		}
	//	}

	//	// Check type alias of func_ret
	//	if (!type_alias[func_ret]) {
	//		if (auto x = type_alias[func_ret]) {
	//			for (auto y: *x) {
	//				if (y == callee_ret) {
	//					check = true;
	//					break;
	//				}
	//			}
	//		}
	//	}

	//	if (!check)
	//		return false;
	//}

	//errs() << "func_ty->dump(): "; func_ty->dump();
	//errs() << "callee_ty->dump(): "; callee_ty->dump();

	// 4. Check arg type
	unsigned params_num = func_ty->getNumParams();

	for (unsigned i=0; i<params_num; i++) {
		bool check = false;
		Type *ty0 = func_ty->getParamType(i);
		Type *ty1 = callee_ty->getParamType(i);

		if (ty0 == ty1) {
			check = true;
		} else if (auto x = type_alias[ty0]) { // Check type alias of ty0
			for (auto y: *x) {
				if (y == ty1) {
					//errs() << "ty0->dump(): "; ty0->dump();
					//errs() << "ty1->dump(): "; ty1->dump();
					//errs() << "alias->dump(): "; y->dump();
					check = true;
					break;
				}
			}
		}

		if (!check)
			return false;
	}

	return true;
}

void CodePtrTagPass::handleIndirectCalls(Module &M) {
	set<Instruction*> call_set;

	for (auto &F: M) {
    // Skip startup code
		if (F.getSection().find(".text.startup") != std::string::npos)
      continue;

		for (auto &BB : F) {
			Function *caller = &F;

			for (auto &I : BB) {
        if (!isIndirectCall(&I))
          continue;

				call_set.insert(&I);
				statNumIndirectCall++;
			}
		}
	}

	for (auto pI: call_set) {
		// Insert echk before pCI
		handleIndirectCall(M, pI);
	}
}

void CodePtrTagPass::handleIndirectCall(Module &M, Instruction *pI) {
	//errs() << "pI->dump(): "; pI->dump();
	FunctionType *fty1 = NULL;
	if (CallInst *pCI = dyn_cast<CallInst>(pI))
		fty1 = pCI->getFunctionType();
	else if (InvokeInst *pII = dyn_cast<InvokeInst>(pI)) {
		fty1 = pII->getFunctionType();
		//errs() << "pII->dump(): "; pII->dump();
		//errs() << "fty1->dump(): "; fty1->dump();
	} else
		ASSERT(false);

	//FunctionType *fty1 = pCI->getFunctionType();
	u_int16_t label = 0;

	if (fty1->isVarArg()) {
		vector<Type*> indices;
		//errs() << "pI->dump(): "; pI->dump();
		for (unsigned i = 0; i < pI->getNumOperands()-1; i++) {
			pI->getOperand(i)->dump();
			indices.push_back(pI->getOperand(i)->getType());
		}
		fty1 = FunctionType::get(fty1->getReturnType(), indices, false);
	}

	bool found = false;
	for (auto x: label_map) {
		FunctionType *fty2 = (x.first)->getFunctionType();
		if (doTypeComparison(fty1, fty2)) {
			label = x.second;
			found = true;
			break;
		}
	}

	if (!found || label == 0) {
		return;
	}

	//if (found) {
	//	errs() << "Found! label: " << label << "\n";
	//}
	//if (!found || label == 0) {
	//	PointerType* func_pty = PointerType::get(fty1, 0);
	//	errs() << "func_pty->dump(): "; func_pty->dump();
	//	if (type_alias[func_pty]) {
	//		errs() << "It has type alias!\n";
	//	}

	//	errs() << "pI->dump(): "; pI->dump();
	//}
	//ASSERT(found);
	//ASSERT(label != 0);

	//Value* callee = pCI->getCalledValue();
	Value* callee = NULL;
	if (CallInst *pCI = dyn_cast<CallInst>(pI))
		callee = pCI->getCalledValue();
	else if (InvokeInst *pII = dyn_cast<InvokeInst>(pI))
		callee = pII->getCalledValue();

	IRBuilder<> Builder(pI);

	// Insert echk rs1, rs2
	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), {Type::getInt8PtrTy(*C), Type::getInt64Ty(*C), Type::getInt64Ty(*C)}, false);
	FunctionType *FuncTypeB = FunctionType::get(Type::getInt8PtrTy(*C), {Type::getInt8PtrTy(*C)}, false);
  Value *arg0 = ConstantInt::get(Type::getInt64Ty(*C), label);
  Value *arg1 = ConstantInt::get(Type::getInt64Ty(*C), temp_cnt++);
	auto castA = Builder.CreateCast(Instruction::BitCast, callee, Type::getInt8PtrTy(*C));
	auto echk = QEMU? M.getOrInsertFunction("__echk_num", FuncTypeA) :
										Intrinsic::getDeclaration(&M, Intrinsic::cpt_echk);

	if (QEMU) {
		Builder.CreateCall(echk, {castA, arg0, arg1}, "");
		auto xtag = M.getOrInsertFunction("__xtag", FuncTypeB);
		auto callA = Builder.CreateCall(xtag, {castA}, "");
		auto castB = Builder.CreateCast(Instruction::BitCast, callA, callee->getType());
		replaceOp(callee, castB, pI);
		//bool check = false;
		//unsigned nth = 0;
		//for (auto op = pI->op_begin(); op != pI->op_end(); op++, nth++) {
		//	if (dyn_cast<Value>(op) == callee) {
		//		pI->setOperand(nth, castB);
		//		check = true;
		//		break;
		//	}
		//}

		//ASSERT(check);
	} else {
		Builder.CreateCall(echk, {castA, arg0}, "");
	}
}

bool CodePtrTagPass::isIndirectCall(Instruction *pI) {
  Function *pF = nullptr;

	if (CallInst *pCI = dyn_cast<CallInst>(pI)) {
    pF = pCI->getCalledFunction();

    if (!pF) {
			FunctionType *fty = pCI->getFunctionType();
			//errs() << "pCI->dump(): "; pCI->dump();
			//errs() << "pCI->numOperands(): "; pCI->getNumOperands();
			//errs() << "fty->dump(): "; fty->dump();
			//errs() << "isVarArg(): " << fty->isVarArg() << "\n";
			//errs() << "getNumParams(): " << fty->getNumParams() << "\n";
			//errs() << "params()->size(): " << fty->params().size() << "\n";

      auto op = pCI->op_end();
      auto func = (--op)->get();

      // Global alias of function is not an indirect call
      if (auto pGA = dyn_cast<GlobalAlias>(func)) {
        return false;
      } 
      
      if (isa<InlineAsm>(pCI->getCalledValue()))
        return false;

      // Skip callinst (bitcast(@func, *))
      auto pV = pCI->getCalledValue();
      if (dyn_cast<Instruction>(pV)) {
      } else if (auto bc_op = dyn_cast<BitCastOperator>(pV)) {
				//errs() << "pCI->dump(): "; pCI->dump();
        if (Function *func = dyn_cast<Function>(bc_op->getOperand(0))) {
          //errs() << "func->getName(): " << func->getName() << "\n";
          return false;
        }

				if (GlobalAlias *alias = dyn_cast<GlobalAlias>(bc_op->getOperand(0))) {
          //errs() << "alias->getName(): " << alias->getName() << "\n";
					return false;
				} 
      }

      return true;
    }

    return false;
  } else if (InvokeInst *pII = dyn_cast<InvokeInst>(pI)) {
    pF = pII->getCalledFunction();

    if (!pF) {
			//errs() << "pII->dump(): "; pII->dump();
      auto op = pII->op_end();
      auto func = (--op)->get();

      // Global alias of function is not an indirect call
      if (auto pGA = dyn_cast<GlobalAlias>(func)) {
        return false;
      } 
      
      if (isa<InlineAsm>(pII->getCalledValue()))
        return false;

      // Skip callinst (bitcast(@func, *))
      auto pV = pII->getCalledValue();
      if (dyn_cast<Instruction>(pV)) {
      } else if (auto bc_op = dyn_cast<BitCastOperator>(pV)) {
        if (Function *func = dyn_cast<Function>(bc_op->getOperand(0))) {
          //errs() << "func->dump(): "; func->dump();
          return false;
        }

				if (GlobalAlias *alias = dyn_cast<GlobalAlias>(bc_op->getOperand(0))) {
          //errs() << "alias->getName(): " << alias->getName() << "\n";
					return false;
				} 
      }

      return true;
    }
  }

  return false;
}

void CodePtrTagPass::handleIntrinsicFunctions(Module &M) {
	for (auto &F: M) {
    for (auto &BB: F) {
      for (auto &I: BB) {
				Function *pF = nullptr;

        if (CallInst *pCI = dyn_cast<CallInst>(&I))
          pF = pCI->getCalledFunction();
        else if (InvokeInst *pII = dyn_cast<InvokeInst>(&I))
          pF = pII->getCalledFunction();

				if (pF && pF->isDeclaration()) {
					if (CallInst *pCI = dyn_cast<CallInst>(&I)) {
						unsigned n = pCI->getNumOperands();

						for (unsigned i=0; i<n-1; i++) {
							Value *pV = pCI->getOperand(i);
							Type *ty = pV->getType();

							if (auto pty = dyn_cast<PointerType>(ty)) {
								if (pty->getElementType()->isFunctionTy()) {
									IRBuilder<> Builder(&I);		
									Instruction *callA = insertXtag(M, &Builder, pV);
									auto castA = Builder.CreateCast(Instruction::BitCast, callA, pV->getType());
									pCI->setOperand(i, castA);
								}
							}
						}
					} else if (InvokeInst *pII = dyn_cast<InvokeInst>(&I)) {
						unsigned n = pII->getNumOperands();

						for (unsigned i=0; i<n-1; i++) {
							Value *pV = pII->getOperand(i);
							Type *ty = pV->getType();

							if (auto pty = dyn_cast<PointerType>(ty)) {
								if (pty->getElementType()->isFunctionTy()) {
									IRBuilder<> Builder(&I);		
									Instruction *callA = insertXtag(M, &Builder, pV);
									auto castA = Builder.CreateCast(Instruction::BitCast, callA, pV->getType());
									pII->setOperand(i, castA);
								}
							}
						}
					}
        }
      }
    }
  }
}

void CodePtrTagPass::buildTypeString(const Type *T, llvm::raw_string_ostream &O) {
  if (T->isPointerTy()) {
    O << "ptr.";
    buildTypeString(T->getPointerElementType(), O);
  } else if (T->isStructTy()) {
		auto sty = dyn_cast<StructType>(T);
		std::regex e("^(\\w+\\.\\w+)(\\.\\w+)?$");

		if (sty->isLiteral()) {
			O << std::regex_replace("str.", e, "$1");
		} else {
			auto structName = dyn_cast<StructType>(T)->getStructName();
			O << std::regex_replace(structName.str(), e, "$1");
		}
  } else if (T->isArrayTy()) {
    O << "arr.";
    buildTypeString(T->getArrayElementType(), O);
  } else if (T->isFunctionTy()) {
    auto FuncTy = dyn_cast<FunctionType>(T);
    O << "f.";
    buildTypeString(FuncTy->getReturnType(), O);

    for (auto p = FuncTy->param_begin(); p != FuncTy->param_end(); p++) {
      buildTypeString(*p, O);
    }
  } else if (T->isVectorTy()) {
    O << "vec." << T->getVectorNumElements();
    buildTypeString(T->getVectorElementType(), O);
  } else if (T->isVoidTy()) {
    O << "v";
  } else {
    /* Make sure we've handled all cases we want to */
    assert(T->isIntegerTy() || T->isFloatingPointTy());
    T->print(O);
  }
}


uint64_t CodePtrTagPass::getTypeIDFor(const Type *T) {
  if (!T->isPointerTy())
    return 0; // Not a pointer, hence no type ID for this one

  // TODO: This should perform caching, so calling the same Type will not
  // reprocess the stuff. Use a Dictionary-like ADT is suggested.
  decltype(TypeIDCache)::iterator id;
  if ((id = TypeIDCache.find(T)) != TypeIDCache.end())
    return id->second;

  uint64_t theTypeID = 0;
  std::string buf;
  llvm::raw_string_ostream typeIdStr(buf);

  buildTypeString(T, typeIdStr);
  typeIdStr.flush();

  // Prepare SHA3 generation
  auto rawBuf = buf.c_str();
  mbedtls_sha3_context sha3_context;
  mbedtls_sha3_type_t sha3_type = MBEDTLS_SHA3_256;
  mbedtls_sha3_init(&sha3_context);

  // Prepare input and output variables
  auto *input = reinterpret_cast<const unsigned char *>(rawBuf);
  auto *output = new unsigned char[32]();

  // Generate hash
  auto result = mbedtls_sha3(input, buf.length(), sha3_type, output);
  if (result != 0)
    llvm_unreachable("SHA3 hashing failed :(");
  memcpy(&theTypeID, output, sizeof(theTypeID));
  // TODO need to fix delete[] output;

  TypeIDCache.emplace(T, theTypeID);

  return theTypeID;
}

Constant *CodePtrTagPass::getTypeIDConstantFrom(const Type &T, LLVMContext &C) {
  return Constant::getIntegerValue(Type::getInt64Ty(C),
                                   //APInt(64, getTypeIDFor(&T) & 0xFFFF));
                                   APInt(64, getTypeIDFor(&T)));

  //return Constant::getIntegerValue(Type::getInt64Ty(C),
  //                                 APInt(64, 0));
}

void CodePtrTagPass::init(Module &M) {
	Function *start = nullptr;

	for (auto &F : M) {
		if (&F && F.getSection().find(".text.startup") != std::string::npos) {
			start = &F;
			break;
		}
	}

	for (auto &F : M) {
		if (&F && F.getName() == "main") {
		  C = &F.getContext();
			DL = &F.getParent()->getDataLayout();
			main = &F;
			if (!start)
				start = main;
			break;
		}
	}

	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(*C), false);
	entry = Function::Create(FuncTypeA, Function::ExternalLinkage, "__init_cpt", M);
	auto pBB = BasicBlock::Create(*C, "", entry, nullptr);
	ReturnInst::Create(*C, pBB);

	auto &BB = start->front();
	auto &I = BB.front();
	IRBuilder<> Builder(&I);		
	Builder.CreateCall(FuncTypeA, entry);
}

void CodePtrTagPass::printFuncAddr(Module &M) {
	auto &BB = main->front();
	auto &I = BB.front();
	IRBuilder<> Builder(&I);

	for (auto &F : M) {
		if (&F && !F.isDeclaration()) {
			Constant *name = ConstantDataArray::getString(*C, F.getName(), true);

			GlobalVariable* pGV = new GlobalVariable(M, 
        /*Type=*/ name->getType(),
        /*isConstant=*/ true,
        /*Linkage=*/ GlobalValue::PrivateLinkage,
        /*Initializer=*/ 0, // has initializer, specified below
        /*Name=*/ ".func_name");
			pGV->setAlignment(1);
			pGV->setInitializer(name);

			auto castA = Builder.CreateCast(Instruction::BitCast, pGV, Type::getInt8PtrTy(*C));
			auto castB = Builder.CreateCast(Instruction::BitCast, &F, Type::getInt8PtrTy(*C));
			FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt8PtrTy(*C), Type::getInt8PtrTy(*C)}, false);
			auto print = M.getOrInsertFunction("__print_func", FuncTypeA);
			Builder.CreateCall(print, {castA, castB});
		}
	}
}

void CodePtrTagPass::insertCptSet(Module &M) {
  //for (auto &F : M) {
  //  if (&F && !F.isDeclaration()) {
  //    auto &BB = F.front();
  //    auto &I = BB.front();
  //    IRBuilder<> Builder(&I);

  //    Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), func_num++);
  //    FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(M.getContext())}, false);
  //    auto print = F.getParent()->getOrInsertFunction("dpt_print_func", FuncTypeA);
  //    Builder.CreateCall(print, {arg});

	//		for (auto &BB: F) {
	//			for (auto &I: BB) {
	//				if (dyn_cast<ReturnInst>(&I)) {
	//					IRBuilder<> BuilderB(&I);

	//					Value *arg = ConstantInt::get(Type::getInt64Ty(M.getContext()), func_num-1);
	//					FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), {Type::getInt64Ty(M.getContext())}, false);
	//					auto print = F.getParent()->getOrInsertFunction("dpt_print_func_ret", FuncTypeA);
	//					BuilderB.CreateCall(print, {arg});
	//					break;
	//				}
	//			}
	//		}

  //  }
  //}

	// Insert cpt_set() to init configuration
	auto &BB = entry->front();
	auto &I = BB.front();
	IRBuilder<> Builder(&I);

	FunctionType *FuncTypeA = FunctionType::get(Type::getVoidTy(M.getContext()), false);
	auto init = M.getOrInsertFunction("__cpt_set", FuncTypeA);
	Builder.CreateCall(init);
}
